<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(root, nano, _, $) {

    &quot;use strict&quot;

<span id='nano-ui-Grid'>    /**
</span>     * Grid component.
     *
     * @class    nano.ui.Grid
     * @extends  nano.Base
     * @author   ofca &lt;ofca@emve.org&gt;
     * @uses     nano.ui.grid.Column
     * @uses     nano.ui.grid.column.String
     */
    nano.define('nano.ui.Grid', {
        $uses: [
            'nano.ui.grid.Column',
            'nano.ui.grid.column.String'
        ],
        $configs: [
<span id='nano-ui-Grid-cfg-template'>            /**
</span>             * @cfg {String} template
             * Grid html template.
             */
            'template',
<span id='nano-ui-Grid-cfg-columns'>            /**                 
</span>             * @cfg {Array} columns 
             * Grid columns definition.
             */
            'columns',            
<span id='nano-ui-Grid-cfg-sortLocal'>            /**
</span>             * @cfg {Boolean} sortLocal
             * Flag indicating whether sorting should be done
             * in browser or on the server.
             * If loader is defined default value is false,
             * otherwise true.
             *
             * If sortLocal is false then to loading data
             * request are attached two variables:
             * 
             * *  sortby=columnName
             * *  sorttype=asc-or-desc
             */
            'sortLocal'
        ],
        $properties: function() {
            return {
<span id='nano-ui-Grid-property-template'>                /**
</span>                 * @property {String} template
                 * Grid html template.
                 */
                template: '&lt;table class=&quot;{{css}}&quot;&gt;&lt;/table&gt;',
<span id='nano-ui-Grid-property-columns'>                /**                 
</span>                 * @property {Array} columns 
                 * Grid columns definition.
                 * @readonly
                 */
                columns: [],
<span id='nano-ui-Grid-cfg-data'>                /**
</span>                 * @cfg {Array} data
                 * Data to display.
                 */
                data: [],
<span id='nano-ui-Grid-cfg-appendTo'>                /**
</span>                 * @cfg {HTMLElement/String} appendTo
                 * DOMElement to render grid.
                 */
                appendTo: null,
<span id='nano-ui-Grid-cfg-css'>                /**
</span>                 * @cfg {Array} css
                 * Css classes applied to table dom element.
                 */
                css: ['table'],
<span id='nano-ui-Grid-property-localData'>                /**
</span>                 * @property {Boolean} localData
                 * If false, data is loaded async.
                 * @readonly
                 */
                localData: true,
<span id='nano-ui-Grid-property-sortLocal'>                /**
</span>                 * @property {Boolean} sortLocal
                 * Flag indicating whether sorting should be done
                 * in browser or on the server.
                 * If loader is defined default value is false,
                 * otherwise true.
                 *
                 * If sortLocal is false then to loading data
                 * request are attached two variables:
                 * 
                 * *  sortby=columnName
                 * *  sorttype=asc-or-desc
                 */
                sortLocal: false,
<span id='nano-ui-Grid-property-loader'>                /**
</span>                 * @cfg {Function/String} loader Function which will load data.
                 * @property {Function/String} loader
                 * Function which will load data.
                 * @readonly
                 */
                loader: null,
<span id='nano-ui-Grid-property-dom'>                /**
</span>                 * @property {Object} dom 
                 * Handles link to HTMLElements.
                 * @property {Object} dom.table Handler to table HTMLElement. Available after nano.ui.Grid.render() executed.
                 * @readonly
                 */
                dom: {},
<span id='nano-ui-Grid-property-sortedBy'>                /**
</span>                 * @property {String} sortedBy
                 * Name of the column by which grid is sorted.
                 * @readonly
                 */
                sortedBy: null,
<span id='nano-ui-Grid-property-rendered'>                /**
</span>                 * @property {Boolean} rendered True if grid is rendered.
                 * @readonly
                 */
                rendered: false
            }
        },
<span id='nano-ui-Grid-method-constructor'>        /**
</span>         * Constructor.
         *
         *     @example
         *     var grid = new nano.ui.Grid({
         *         appendTo: 'grid'
         *     });
         * 
         * @param  {Object} o Configuration.
         * @constructor
         */
        constructor: function(o) {
            this.$super.prototype.constructor.call(this, o);

            if (o.sortBy) {
                this.sortBy(sortBy);
            }
        },
        setLoader: function(o) {
            var me = this;

            if (_.isFunction(o)) {
                this.loader = o;
            } else if (_.isString(o)) {
                nano.ajax({
                    url: o,
                    method: 'get',
                    dataType: 'json',
                    complete: function(data) {
                        me.data = data;
                        me.renderRows();
                    }
                });
            }

            return this;
        },
        addActions: function(o) {
            _.map(o, function(v, k) { this.addAction(k, v); }, this); 
        },
        addAction: function(path, handler) {
            path = path.split(':');

            var me = this, 
                action = path[1],
                selectors = path[0];

            $(this.renderTo).on(action, selectors, function(e) {
                handler.call(me, this, e);
            });
        },
        setRenderTo: function(value) {
            if (typeof value == 'string') {
                value = document.getElementById(value);
            }

            if ( ! value) {
                throw new Error('nano.ui.Grid: Specified dom element does not exists.');
            }

            this.renderTo = value;
        },
        setColumn: function(o) {
            var type = o.type || 'string';
    
            // Capitalize first char
            type = type.charAt(0).toUpperCase() + type.slice(1);

            o.grid = this;

            var column = nano.create('nano.ui.grid.column.'+type, o);

            this.columns.push(column);

            // Sorting is not set yet
            if ( ! this.sortedBy &amp;&amp; column.sortable) {
                this.sortedBy = column.name;
            }
        },
        setColumns: function(columns) {
            var i = 0, len = columns.length;

            for (; i &lt; len; i++) {
                this.setColumn(columns[i]);
            }
        },
        render: function() {
            this.renderTo.innerHTML = nano.tmpl(this.template, {
                css: this.css.join(' ')
            });

            this.dom.table = this.renderTo.getElementsByTagName('table')[0];
            this.renderHeaders();
            this.renderRows();

            this.rendered = true;
        },
        renderHeaders: function() {
            var html = [],
                cols = this.columns,
                len = cols.length, i = 0, col,
                table = this.dom.table, thead, el;

            for (; i &lt; len; i++) {
                col = cols[i];

                if ( ! col.isVisible()) {
                    continue;
                }

                html[i] = col.renderHeaderCell();
            }

            el = document.createElement('thead');
            el.innerHTML = '&lt;tr&gt;' + html.join('') + '&lt;/tr&gt;';

            thead = table.getElementsByTagName('thead')[0];

            // thead exists, replace it
            if (thead) {
                table.replaceChild(el, thead);
            } else {
                // Insert as first child in any other 
                // node exists in the table
                table.firstChild 
                    ? table.insertBefore(el, table.firstChild)
                    : table.appendChild(el);
            }

            this.addAction('.nano-grid-columnHeader:click', function(el, e) {
                var name = el.getAttribute('data-column-name');
                this.sortBy(name);
            });
        },
        renderRows: function() {
            var me = this,
                data = me.data,
                len = data.length,
                i = 0,
                html = [], 
                table = this.dom.table,
                tbody, thead, el;

            for (; i &lt; len; i++) {
                html[i] = me.renderRow(data[i], i);
            }

            // Create dom element
            el = document.createElement('tbody');
            el.innerHTML = html.join('');

            // Get tbody
            tbody = table.getElementsByTagName('tbody')[0];

            // If exists replace with new one
            if (tbody) {
                table.replaceChild(el, tbody);
            } else {
                thead = table.getElementsByTagName('thead')[0];

                // If thead exists insert after it
                if (thead) {
                    table.insertBefore(el, thead.nextSibling);
                } else {
                    // Insert as first child in any other 
                    // node exists in the table
                    table.firstChild
                        ? table.insertBefore(el, table.firstChild)
                        : table.appendChild(el)
                }
            }
        },
        renderRow: function(data, rowIndex) {
            var html = [], 
                cols = this.columns, 
                i = 0, 
                len = cols.length, col;

            for (; i &lt; len; i++) {
                col = cols[i];

                if ( ! col.isVisible()) {
                    continue;
                }

                html[i] = col.renderCell(col.virtual ? null : data[col.name], data, i, rowIndex);
            }

            return '&lt;tr&gt;' + html.join('') + '&lt;/tr&gt;';
        },
        getColumnBy: function(key, value) {
            var i = 0, list = this.columns, len = list.length;

            for (; i &lt; len; i++) {
                if (list[i][key] == value) return list[i];
            }

            return false;
        },
<span id='nano-ui-Grid-method-sortBy'>        /**
</span>         * Sort grid by column.
         * 
         * @param  {String} column Column index.
         * @param  {Function} func Optional. Sorting function.
         * @return {nano.ui.Grid} this
         * @chainable
         * @method
         */
        sortBy: function(column, func, asc) {            
            var column = this.getColumnBy('name', column);

            if ( ! column) { return; }

            if (column.name != this.sortedBy) {
                this.getColumnBy('name', this.sortedBy).unmarkSorted();
            }

            column.sort(func, asc);
            
            this.sortedBy = column.name;

            this.rendered &amp;&amp; this.renderRows();

            return this;
        }
    });

})(this, this.nano, this._, this.jQuery);</pre>
</body>
</html>
